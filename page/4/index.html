<!DOCTYPE html>
<html class="has-navbar-fixed-top">
<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
<title>
    O
</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">



        
            <meta name="description" content="">
            

                

                        

                                    

                                            

                                                    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
                                                    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">

                                                    
                                                        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
                                                        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">
                                                        

                                                            <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">

                                                            
<link rel="stylesheet" href="/o/css/style.css">


                                                                <script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>

                                                                
                                                                    
                                                                        
                                                                            
                                                                        
                                                                            
                                                                        
                                                                            
                                                                        
                                                                            
                                                                        
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-152053462-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-152053462-1');
</script>


                                                                            
                                                                                
<meta name="generator" content="Hexo 4.2.1"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>
<body>
    
<!-- hexo-inject:begin --><!-- hexo-inject:end --><nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/o/">
                
                <img src="/o/images/logo.png" alt="" height="28">
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item "
               href="/o/archives">归档</a>
            
            <a class="navbar-item "
               href="/o/about">关于</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            <a class="navbar-item search" title="搜索" href="javascript:;">
                <i class="fas fa-search"></i>
            </a>
            
            
            
            <a class="navbar-item" title="GitHub" href="https://github.com/EPSON-LEE" target="_blank" rel="noopener">
                
                <i class="fab fa-github"></i>
                
            </a>
               
            
        </div>
    </div>
</nav>

    <section class="section">
    <div class="container">
    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/o/2019/12/11/git-revert/" itemprop="url">如何去撤销一个已提交的 commit 节点</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2019-12-11T09:51:37.000Z" itemprop="datePublished">12月 11 2019</time>
        </span>
        
        
        <span class="column is-narrow">
            
            
            4 分钟 读完 (约 668 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="撤销某一个具体的节点"><a href="#撤销某一个具体的节点" class="headerlink" title="撤销某一个具体的节点"></a>撤销某一个具体的节点</h2><p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git revert a7d8dcaa4e25667c9aaaf2a0809aca7fe1a27b6d</span><br></pre></td></tr></table></figure></p>
<p>但是当这个节点是一个 merge 节点的时候， 你根本无法去 revert 这个节点，因为你不知道 merge 的哪一条分支应该作为主线，哪个分支作为他撤销后的主分支，因此git 会输出错误信息:</p>
<p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: commit cae5381823aad7c285d017e5cf7e8bc4b7b12240 is a merge but no -m option was given.</span><br></pre></td></tr></table></figure></p>
<p>让我们来看看这个 m 参数代表什么</p>
<blockquote>
<p>Usually you cannot revert a merge because you do not know which side of the merge should be considered the mainline. This option specifies the parent number (starting from 1) of the mainline and allows revert to reverse the change relative to the specified parent.</p>
</blockquote>
<blockquote>
<p>Reverting a merge commit declares that you will never want the tree changes brought in by the merge. As a result, later merges will only bring in tree changes introduced by commits that are not ancestors of the previously reverted merge. This may or may not be what you want</p>
</blockquote>
<p>翻译过来就是</p>
<blockquote>
<p>通常情况下，你无法 revert 一个 merge，因为你不知道 merge 的哪一条线应该被视为主线。这个选项（-m）指定了主线的 parent 的代号（从1开始），并允许以相对于指定的 parent 的进行 revert。</p>
</blockquote>
<blockquote>
<p>revert 一个 merge commit 意味着你将完全不想要来自 merge commit 带来的 tree change。 因此，之后的 merge 只会引入那些不是之前被 revert 的那个 merge 的祖先引入的 tree change，这可能是也可能不是你想要的。</p>
</blockquote>
<p>如同下图所示，revert 到 ‘thumbup-feature’ 的时候不知道 到底是 revert 到绿色的线还是紫色的线。</p>
<p><img src="https://raw.githubusercontent.com/EPSON-LEE/image-hosting/master/20191211184947.png" alt></p>
<p>也可以使用 git show 命令查看相关信息 </p>
<p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git show</span><br><span class="line"></span><br><span class="line">输出内容：</span><br><span class="line"></span><br><span class="line">commit cae5381823aad7c285d017e5cf7e8bc4b7b12240</span><br><span class="line">Merge: edf99ca 125cfdd</span><br><span class="line">Date:   Thu Apr 12 18:27:21 2018 +0800</span><br><span class="line"></span><br><span class="line">    Merge tag &#39;thumbup-feature&#39;</span><br></pre></td></tr></table></figure><br>如下图标示的 parent1 对应</p>
<p><img src="https://raw.githubusercontent.com/EPSON-LEE/image-hosting/master/20191211185856.png" alt></p>
<h2 id="执行-git-revert-cae5381-m-1"><a href="#执行-git-revert-cae5381-m-1" class="headerlink" title="执行 git revert cae5381 -m 1"></a>执行 git revert cae5381 -m 1</h2><p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git revert cae5381 -m 1</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">Revert &quot;Merge tag &#39;thumbup-feature&#39;&quot;</span><br><span class="line"></span><br><span class="line">This reverts commit cae5381823aad7c285d017e5cf7e8bc4b7b12240, reversing</span><br><span class="line">changes made to edf99ca31755a27b0a43b290263ed810833a95c4.</span><br><span class="line"></span><br><span class="line">[master f0aac26] Revert &quot;Merge tag &#39;thumbup-feature&#39;&quot;</span><br><span class="line"> 2 files changed, 2 deletions(-)</span><br><span class="line"> delete mode 100644 file3</span><br><span class="line"> delete mode 100644 file4</span><br></pre></td></tr></table></figure></p>
<p>复制代码file3 和 file4 是 feature branch 上的 commit 引入的文件，被正确地删掉了</p>
<h2 id="执行-git-revert-cae5381-m-2"><a href="#执行-git-revert-cae5381-m-2" class="headerlink" title="执行 git revert cae5381 -m 2"></a>执行 git revert cae5381 -m 2</h2><p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard d208cba </span><br><span class="line">git revert cae5381 -m 2</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line"></span><br><span class="line">[master 2c5a0ee] Revert &quot;Merge tag &#39;thumbup-feature&#39;&quot;</span><br><span class="line"> 2 files changed, 2 deletions(-)</span><br><span class="line"> delete mode 100644 file5  </span><br><span class="line"> delete mode 100644 file6</span><br></pre></td></tr></table></figure></p>
<p>这种 revert 把 master 在 feature branch 期间进行的 commit 都给干掉了。</p>
<p>本文绝大部分的内容和数据都引用自 ULIVZ 的文章:</p>
<ul>
<li><a href="https://juejin.im/post/5acf4db8f265da239148822d" target="_blank" rel="noopener">当你决定去 revert 一个merge commit</a></li>
</ul>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/o/2019/12/10/Functional/" itemprop="url">如何理解函数式编程</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2019-12-10T13:09:49.000Z" itemprop="datePublished">12月 10 2019</time>
        </span>
        
        
        <span class="column is-narrow">
            
            
            14 分钟 读完 (约 2121 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <p>要回答这个问题，需要知道什么是编程范式。</p>
<h2 id="编程范式"><a href="#编程范式" class="headerlink" title="编程范式"></a>编程范式</h2><p>函数式编程范式是一种 <strong>编程范式</strong>。<br>我们通常见到的编程范式有 <strong>命令式编程(Imperative programming)</strong>、<strong>函数式编程</strong> 和 <strong>逻辑式编程</strong>，面向对象编程也属于命令式编程的一种。</p>
<h3 id="命令式编程"><a href="#命令式编程" class="headerlink" title="命令式编程"></a>命令式编程</h3><p>命令式编程是面向<strong>计算机硬件</strong>的抽象，有<strong>变量</strong>（对应着存储单元）、<strong>赋值语句（获取指令和存储指令）</strong>，<strong>表达式（内存引用）</strong>和<strong>控制语句（跳转指令）</strong>。总而言之，命令式编程就是一个<strong>冯诺伊曼机</strong>的<em></em>指令序列**。</p>
<h3 id="函数式编程的本质"><a href="#函数式编程的本质" class="headerlink" title="函数式编程的本质"></a>函数式编程的本质</h3><p>而函数式编程是面向数学的抽象，将计算描述为一种<strong>表达式值</strong>，可以这么说：一个函数就是一个<strong>表达式值</strong></p>
<p>函数式编程中的函数这个术语不是说计算机中的函数（实际上为 Subroutine，而是指数学中的函数，也就是自变量的映射。也就是说一个函数的值仅决定于函数参数的值，不依赖其他状态。比如 sqrt(x)函数计算x的平方根，只要 x 不变，无论何时调用，调用几次值都是不变的。</p>
<p>在函数式语言中，<strong>函数作为一等公民</strong>，可以在任何地方定义，在函数内或函数外，可以作为函数的参数和返回值，可以对函数进行组合。</p>
<p>纯函数式编程中的<strong>变量</strong>也不是命令式编程中的变量，即存储状态状态的单元，而是代数中的变量，即一个值的名称。变量的值是不可变的（immutable），也就是说不允许像命令式编程语言中的那样多次给一个变量赋值。 例如 在命令式编程语言中我们写的“x = x + 1”，这依赖可变状态的事实，拿给程序看是正确的，但是拿给数学家看，却被认为这个等式为假。</p>
<p>函数式语言的如条件语句，循环语句也不是命令式编程语言中的<strong>控制语句</strong>，而是函数式编程中的语法糖。</p>
<p>严格意思上的函数式编程意味着不使用可变的变量，赋值，循环和其他命令式结构进行编程。</p>
<p>从理论上说，函数式语言也不是通过<strong>冯诺伊曼</strong>体系结构的机器上运行的，而是通过<strong>λ演算</strong>来运行的，就是通过<strong>变量替换</strong>的方式进行，变量替换为其值或表达式，函数也替换为其表达式，并根据运算符进行计算。λ演算是<strong>图灵完全（Turing completeness）</strong>的，但是大多数情况，函数式程序还是被编译成（冯诺依曼机的）机器语言的指令执行的。</p>
<h3 id="函数式编程的好处"><a href="#函数式编程的好处" class="headerlink" title="函数式编程的好处"></a>函数式编程的好处</h3><p>由于命令式编程语言也可以通过类似函数指针的方式来实现高阶函数，函数式的最主要的好处主要是不可变性带来的。没有可变的状态，函数就是引用透明（Referential transparency）的和没有副作用（No Side Effect）。<br><br>一个好处是，函数即不依赖外部的状态也不修改外部的状态，函数调用的结果不依赖调用的时间和位置，这样写的代码容易进行推理，不容易出错。这使得单元测试和调试都更容易。</p>
<p>由于函数是引用透明的，以及函数式编程不像命令式编程那样关注执行步骤，这个系统提供了优化函数式程序的空间，包括惰性求值和并性处理。</p>
<p>还有一个好处是，由于函数式语言是面向数学的抽象，更接近人的语言，而不是机器语言，代码会比较简洁，也更容易被理解。</p>
<h3 id="函数式编程的特性"><a href="#函数式编程的特性" class="headerlink" title="函数式编程的特性"></a>函数式编程的特性</h3><p>由于变量值是不可变的，对于值的操作并不是修改原来的值，而是修改新产生的值，原来的值保持不便。例如一个Point类，其moveBy方法不是改变已有Point实例的x和y坐标值，而是返回一个新的Point实例。</p>
<p><figure class="highlight scala hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span>(<span class="hljs-params">x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span></span>)</span>&#123;</span><br><span class="line">  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toString</span></span>() = <span class="hljs-string">"Point ("</span> + x + <span class="hljs-string">", "</span> + y + <span class="hljs-string">")"</span> </span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">moveBy</span></span>(deltaX: <span class="hljs-type">Int</span>, deltaY: <span class="hljs-type">Int</span>) = &#123;</span><br><span class="line">    <span class="hljs-keyword">new</span> <span class="hljs-type">Point</span>(x +   deltaX, y + deltaY)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>（示例来源：Anders Hejlsberg在echDays 2010上的演讲）</p>
<p>同样由于变量不可变，纯函数编程语言无法实现循环，这是因为<strong>for循环</strong>使用可变的状态作为计数器，而<strong>While</strong>循环或<strong>DoWhile</strong>循环需要可变的状态作为跳出循环的条件。因此在函数式语言里就只能使用递归来解决迭代问题，这使得函数式编程严重依赖递归。</p>
<p>通常来说，算法都有 <strong>递推 (iterative)</strong> 和 <strong>递归（recursive)</strong> 两种定义，以阶乘为例，阶乘的递推定义为：</p>
<p><img src="https://raw.githubusercontent.com/EPSON-LEE/image-hosting/master/20200110235529.png" alt></p>
<p>阶乘的定义为</p>
<p><img src="https://raw.githubusercontent.com/EPSON-LEE/image-hosting/master/20200110235647.png" alt></p>
<p>递推定义的计算时需要使用一个累积器保存每个迭代的中间计算结果，Java代码如下：</p>
<p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fact</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> acc = <span class="hljs-number">1</span>;</span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">    acc = acc * k;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">return</span> acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>而递归定义的计算的Scala代码如下：</p>
<p><figure class="highlight scala hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fact</span></span>(n: <span class="hljs-type">Int</span>):<span class="hljs-type">Int</span>= &#123;</span><br><span class="line">  <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span></span><br><span class="line">  n * fact(n<span class="hljs-number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到，没有使用循环，没有使用可变的状态，函数更短小，不需要显示地使用累积器保存中间计算结果，而是使用参数n（在栈上分配）来保存中间计算结果。</p>
<p>当然，这样的递归调用有更高的开销和局限（调用栈深度），那么尽量把递归写成尾递归的方式，编译器会自动优化为循环。</p>
<p>一般来说，递归这种方式于循环相比被认为是更符合人的思维的，即告诉机器做什么，而不是告诉机器怎么做。递归还是有很强大的表现力的。</p>
<h3 id="函数式语言中的特性"><a href="#函数式语言中的特性" class="headerlink" title="函数式语言中的特性"></a>函数式语言中的特性</h3><ul>
<li>高阶函数（High-order function）</li>
<li>偏函数（Particial Applied function）</li>
<li>Currying</li>
<li>闭包 （closure）</li>
<li>惰性求值 （Lazy evaluation）、（call by need）</li>
</ul>
<ol>
<li>高阶函数</li>
</ol>
<p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">funcA, funcB, value</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> funcA(value) + funcB(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li>偏函数</li>
</ol>
<p>偏函数则是固定一个函数的一个或者多个参数，也就是将一个 n 元函数转换成一个 n - x 元函数</p>
<p>偏函数和 currying 有一定的联系</p>
<p>引用 <a href="https://github.com/hemanth/functional-programming-jargon#partial-application" target="_blank" rel="noopener">functional-programming-jargon</a> 的话来说就是：</p>
<blockquote>
<p>Curried functions are automatically partially applied.</p>
</blockquote>
<p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 计算 a、b 的和</span></span><br><span class="line">add(a, b)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 使用偏函数</span></span><br><span class="line"><span class="hljs-keyword">var</span> addOne = partial(add, <span class="hljs-number">1</span>)</span><br><span class="line"></span><br><span class="line">addOne(<span class="hljs-number">2</span>)</span><br></pre></td></tr></table></figure></p>
<ol start="3">
<li>Currying</li>
</ol>
<p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 执行 add 函数，一次传入两个参数即可</span></span><br><span class="line">add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 假设有一个 curry 函数可以做到柯里化</span></span><br><span class="line"><span class="hljs-keyword">var</span> addCurry = curry(add);</span><br><span class="line">addCurry(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>) <span class="hljs-comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<p>4.惰性求值</p>
<p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> a = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">b</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line">a(<span class="hljs-number">3</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>函数式编程是给软件开发者提供的另一套工具箱，为我们提供了另外一种抽象和思考的方式。 函数式编程也有不太擅长的场合，比如处理可变状态和处理IO，要么引入可变变量，要么通过<strong>Monad</strong>来进行封装（如State Monad和IO Monad）</p>
<p>参考资料</p>
<ul>
<li><p><a href="https://www.zhihu.com/question/28292740" target="_blank" rel="noopener">本文大部分都参考了这篇文章：如何理解函数式编程 中「用心阁」的回答</a></p>
</li>
<li><p>[]</p>
</li>
<li><p><a href="https://www.zhihu.com/question/19635359/answer/172074046" target="_blank" rel="noopener">知乎 17点的回答</a></p>
</li>
<li><p><a href="https://github.com/mqyqingfeng/Blog/issues/42" target="_blank" rel="noopener">JavaScript专题之函数柯里化</a></p>
</li>
<li><p><a href="https://github.com/xitu/gold-miner/blob/master/TODO/functors-categories.md" target="_blank" rel="noopener">掘金翻译：Functor 与 Category （软件编写）（第六部分）</a></p>
</li>
</ul>
<p>其他等待理解的</p>
<ul>
<li>图灵机完备</li>
<li>lamda 演算</li>
<li>SICP</li>
<li>Haskell</li>
<li>Monald</li>
</ul>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/o/2019/12/10/http-smuggling/" itemprop="url">HTTP 请求走私</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2019-12-10T03:00:40.000Z" itemprop="datePublished">12月 10 2019</time>
        </span>
        
        
        <span class="column is-narrow">
            
            
            几秒 读完 (约 15 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <p>参考：</p>
<ul>
<li><a href="https://paper.seebug.org/1048/" target="_blank" rel="noopener">知道创宇：HTTP 走私</a></li>
</ul>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/o/2019/12/08/stack-heap/" itemprop="url">JavaScript 的运行机制</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2019-12-08T06:05:10.000Z" itemprop="datePublished">12月 8 2019</time>
        </span>
        
        
        <span class="column is-narrow">
            
            
            1 分钟 读完 (约 141 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <p>参考： </p>
<ul>
<li><p><a href="http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D" target="_blank" rel="noopener">Philip Roberts 制作的一个实时监控代码中 Event Loop 的监控页面</a></p>
</li>
<li><p><a href="https://www.zhihu.com/search?type=content&q=javaScript%20%E4%B8%AD%E7%9A%84%E5%A0%86%E6%A0%88" target="_blank" rel="noopener">知乎： JavaScript 中的堆栈</a></p>
</li>
<li><p><a href="https://youtu.be/8aGhZQkoFbQ" target="_blank" rel="noopener">JSConf 2014 Philip Roberts 关于 Event Loop 的解释</a></p>
</li>
<li><p><a href="http://www.ruanyifeng.com/blog/2013/11/stack.html" target="_blank" rel="noopener">阮一峰：Stack 的三种含义</a></p>
</li>
</ul>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/o/2019/12/06/promise/" itemprop="url">Promise 碎片 （等待整理）</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2019-12-06T06:43:38.000Z" itemprop="datePublished">12月 6 2019</time>
        </span>
        
        
        <span class="column is-narrow">
            
            
            9 分钟 读完 (约 1320 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <blockquote>
<p>我所做的一切，不过是在取悦一个影子</p>
</blockquote>
<h3 id="什么是-Promise"><a href="#什么是-Promise" class="headerlink" title="什么是 Promise ?"></a>什么是 Promise ?</h3><ol>
<li>定义：Promise 是一个对象，他会在未来的某个时刻生成一个值，已完成 （resolved）的值或者一个没有完成的理由。</li>
<li>特性：Promise 存在三个状态  FULLFILLED （已完成）、REJECTED （已拒绝）、PENDING （等待中）</li>
<li>回调：Promise 的使用者可以附上回调函数来处理已完成的值或者拒绝的原因</li>
</ol>
<p>Promise 是热切的，一旦 promise 的构造函数被调用，它就会开始执行你交给它的任务。如果你需要一个懒惰的，请看 <a href="https://github.com/Reactive-Extensions/RxJS" target="_blank" rel="noopener">observables</a> 或者 <a href="https://github.com/rpominov/fun-task" target="_blank" rel="noopener">task</a>。</p>
<p><img src="https://raw.githubusercontent.com/EPSON-LEE/image-hosting/master/WeChat6f9e35474509f44dc8831b91563615d0.png" alt></p>
<h3 id="Promise-用法"><a href="#Promise-用法" class="headerlink" title="Promise 用法"></a>Promise 用法</h3><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-comment">// Your code</span></span><br><span class="line">  <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* 异步操作成功 */</span>) &#123;</span><br><span class="line">    resolve(value)</span><br><span class="line">  &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">    reject(value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-comment">// success</span></span><br><span class="line">&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-comment">// error</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/EPSON-LEE/image-hosting/master/20191206182531.png" alt="Promise Polifil"></p>
<h3 id="Promise-API"><a href="#Promise-API" class="headerlink" title="Promise API"></a>Promise API</h3><p>Promise 规范有很多，Promise A、 Promise B、 Promise A+、Promise D</p>
<p>目前 ES6 的 Promise 是基于 Promise A+ 实现的</p>
<p>我们知道 Promise 是一个构造函数，需要用 new 调用，并有以下几个 api：( 从哪里知道？ 怎么知道？)</p>
<p>API: </p>
<p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Promise</span>(<span class="hljs-params">resolver</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">Promise</span>.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">onResolved</span>) </span>&#123;&#125;</span><br><span class="line"><span class="hljs-built_in">Promise</span>.prototype.catch = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">onRejected</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">Promise</span>.resolve = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="hljs-built_in">Promise</span>.reject = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="hljs-built_in">Promise</span>.race = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="hljs-built_in">Promise</span>.all = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>同步任务（存放在执行栈）</p>
<p>异步任务 （存放在异步队列） 异步任务又分为宏任务和微任务</p>
<p>Chrome: </p>
<blockquote>
<p>宏任务 Task: setTimeout setInterval setImmediate(IE专用) messageChannel</p>
</blockquote>
<p>等待执行栈和微任务队列都执行完毕才会执行，并且在执行完每一个宏任务之后，会去看看微任务队列有没有新添加的任务，如果有，会先将微任务队列中的任务清空，才会继续执行下一个宏任务</p>
<blockquote>
<p>微任务 microTask：promise MutationObserver…</p>
</blockquote>
<p>当执行栈中的代码执行完毕，会在执行宏任务队列之前先看看微任务队列中有没有任务，如果有会先将微任务队列中的任务清空才会去执行宏任务队列</p>
<p>Node: </p>
<blockquote>
<p>宏任务 Task: setTimeout setInterval…</p>
</blockquote>
<blockquote>
<p>微任务 microTask: process.nextTric promise setImmediate</p>
</blockquote>
<p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> isFulfilled = <span class="hljs-literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    resolve(<span class="hljs-number">2</span>);</span><br><span class="line"></span><br><span class="line">    isFulfilled = <span class="hljs-literal">true</span>;</span><br><span class="line"></span><br><span class="line">  &#125;, <span class="hljs-number">50</span>);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">d.then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onFulfilled</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-built_in">console</span>.log(isFulfilled == <span class="hljs-literal">true</span>)</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>Promise 的零碎实现： </p>
<p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> PENDING = <span class="hljs-string">"PENDING"</span></span><br><span class="line"><span class="hljs-keyword">const</span> RESOLVED = <span class="hljs-string">"RESOLVED"</span></span><br><span class="line"><span class="hljs-keyword">const</span> REJECTED = <span class="hljs-string">"REJECTED"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 值穿透</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 构造函数</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPromise</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">constructor</span>(exexutor) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">this</span>.status = PENDING</span><br><span class="line">    <span class="hljs-keyword">this</span>.value = <span class="hljs-literal">undefined</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 回调函数</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.onResolvedCallback = []</span><br><span class="line">    <span class="hljs-keyword">this</span>.onRejectedCallback = []</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// inner resolve</span></span><br><span class="line">    <span class="hljs-keyword">let</span> _resolved = <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">       * 这里增加 setTimeout 是为了避免这种情况的出现</span></span><br><span class="line"><span class="hljs-comment">       *  promise2 = new MyPromise(function(resolve, reject) &#123;</span></span><br><span class="line"><span class="hljs-comment">       *    promise2().then(() =&gt; &#123;</span></span><br><span class="line"><span class="hljs-comment">       *      console.log(1111)</span></span><br><span class="line"><span class="hljs-comment">       *    &#125;)</span></span><br><span class="line"><span class="hljs-comment">       *  &#125;)</span></span><br><span class="line"><span class="hljs-comment">       * </span></span><br><span class="line"><span class="hljs-comment">       */</span></span><br><span class="line">      setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">          <span class="hljs-keyword">this</span>.status = RESOLVED</span><br><span class="line">          <span class="hljs-keyword">this</span>.value = value</span><br><span class="line">          <span class="hljs-comment">// 针对非链式调用</span></span><br><span class="line">          <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">           * P = new Promise()</span></span><br><span class="line"><span class="hljs-comment">           * </span></span><br><span class="line"><span class="hljs-comment">           * P.then()</span></span><br><span class="line"><span class="hljs-comment">           * </span></span><br><span class="line"><span class="hljs-comment">           * P.then()</span></span><br><span class="line"><span class="hljs-comment">           */</span></span><br><span class="line">          <span class="hljs-keyword">this</span>.onResolvedCallback.forEach(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> cb(value))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// inner reject</span></span><br><span class="line">    <span class="hljs-keyword">let</span> _rejected = <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.status = REJECTED</span><br><span class="line">        <span class="hljs-keyword">this</span>.value = reason</span><br><span class="line">          <span class="hljs-comment">// 针对非链式调用</span></span><br><span class="line">        <span class="hljs-keyword">this</span>.onRejectedCallback.forEach(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> cb(reason))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">      exexutor(_resolved, _rejected)</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (err) &#123;</span><br><span class="line">      _rejected(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 原型链表</span></span><br><span class="line">  then(onResolved, onRejected) &#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> promise2</span><br><span class="line">    <span class="hljs-keyword">let</span> self = <span class="hljs-keyword">this</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 根据标准规定, 如果 then 的参数不是一个函数那么, 就抛出</span></span><br><span class="line">    onResolved = <span class="hljs-keyword">typeof</span> onResolved === <span class="hljs-string">'function'</span> ? onResolved : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123; <span class="hljs-keyword">return</span> value &#125;</span><br><span class="line">    onRejected = <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">'function'</span> ? onRejected : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">reason</span>) </span>&#123; <span class="hljs-keyword">return</span> reason &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">      <span class="hljs-comment">// 如果当前的Promise还处于pending状态，我们并不能确定调用onResolved还是onRejected，</span></span><br><span class="line">      <span class="hljs-comment">// 只能等到Promise的状态确定后，才能确实如何处理。</span></span><br><span class="line">      <span class="hljs-comment">// 所以我们需要把我们的**两种情况**的处理逻辑做为callback放入promise1(此处即this/self)的回调数组里</span></span><br><span class="line">      <span class="hljs-comment">// 逻辑本身跟第一个if块内的几乎一致，此处不做过多解释</span></span><br><span class="line">      <span class="hljs-keyword">return</span> promise2 = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        self.onResolvedCallback.push(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;</span><br><span class="line">          <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">var</span> x = onResolved(self.value)</span><br><span class="line">            <span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">              x.then(resolve, reject)</span><br><span class="line">            &#125;</span><br><span class="line">            resolve(x)</span><br><span class="line">          &#125; <span class="hljs-keyword">catch</span> (e) &#123;</span><br><span class="line">            reject(e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        self.onRejectedCallback.push(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">reason</span>) </span>&#123;</span><br><span class="line">          <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">var</span> x = onRejected(self.value)</span><br><span class="line">            <span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) &#123;</span><br><span class="line">              x.then(resolve, reject)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="hljs-keyword">catch</span> (e) &#123;</span><br><span class="line">            reject(e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === RESOLVED) &#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> promise2 = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, rejected</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">          x = onResolved(self.value)</span><br><span class="line">          <span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> MyPromise) &#123; <span class="hljs-comment">// 如果onResolved的返回值是一个Promise对象，直接取它的结果做为promise2的结果</span></span><br><span class="line">            x.then(resolve, rejected)</span><br><span class="line">          &#125;</span><br><span class="line">          resolve(x) <span class="hljs-comment">// 否则，以它的返回值做为promise2的结果</span></span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (err) &#123;</span><br><span class="line">          rejected(err)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === REJECTED) &#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> promise2 = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, rejected</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">          x = onRejected(self.value)</span><br><span class="line">          <span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> MyPromise) &#123; <span class="hljs-comment">// 如果onResolved的返回值是一个Promise对象，直接取它的结果做为promise2的结果</span></span><br><span class="line">            x.then(resolve, rejected)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (err) &#123;</span><br><span class="line">          rejected(err)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// then 方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> isFulfilled = <span class="hljs-literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    resolve(<span class="hljs-number">2</span>);</span><br><span class="line"></span><br><span class="line">    isFulfilled = <span class="hljs-literal">true</span>;</span><br><span class="line"></span><br><span class="line">  &#125;, <span class="hljs-number">50</span>);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">d.then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onFulfilled</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-built_in">console</span>.log(isFulfilled == <span class="hljs-literal">true</span>)</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 测试</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, rejected</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'pending'</span>)</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;, <span class="hljs-number">1000</span>);</span><br><span class="line">&#125;).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">let</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, rejected</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'pending'</span>)</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;, <span class="hljs-number">1000</span>);</span><br><span class="line">&#125;).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>参考</p>
<ul>
<li><a href="https://juejin.im/post/5d59757f6fb9a06ae76405c6" target="_blank" rel="noopener">从零一步一步实现一个完整版的Promise</a></li>
<li><a href="https://juejin.im/post/5aa7868b6fb9a028dd4de672" target="_blank" rel="noopener">https://juejin.im/post/5aa7868b6fb9a028dd4de672</a></li>
</ul>
<ul>
<li><a href="https://malcolmyu.github.io/2015/06/12/Promises-A-Plus/" target="_blank" rel="noopener">Promise A+ 规范</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/21834559" target="_blank" rel="noopener">史上最易读懂的 Promise/A+ 完全实现</a></li>
<li><a href="https://github.com/xieranmaya/blog/issues/3" target="_blank" rel="noopener">剖析Promise内部结构，一步一步实现一个完整的、能通过所有Test case的Promise类</a></li>
</ul>
<p>后续</p>
<ul>
<li><a href="https://github.com/xieranmaya/blog/issues/5" target="_blank" rel="noopener">从如何停掉 promise 链说起</a></li>
</ul>
<p>拓展</p>
<ul>
<li><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank" rel="noopener">国内绝大部分 Task MicroTask 的来源</a></li>
<li><a href="https://github.com/folktale/data.task/blob/master/lib/task.js" target="_blank" rel="noopener">评论区：Monad的Data.task 实现Promise </a></li>
</ul>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/o/2019/11/29/Linux-version/" itemprop="url">升级 Node 遇到的一些问题</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2019-11-29T04:17:07.000Z" itemprop="datePublished">11月 29 2019</time>
        </span>
        
        
        <span class="column is-narrow">
            
            
            2 分钟 读完 (约 338 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <p><img src="https://raw.githubusercontent.com/EPSON-LEE/image-hosting/master/20191129143017.png" alt></p>
<p>今天在将 node 从 8.6.0 升级到 node 12.0.4 时候遇到这么一个问题:</p>
<p><img src="https://raw.githubusercontent.com/EPSON-LEE/image-hosting/master/20191129142559.png" alt></p>
<p>这是因为 gnulib glib 和 glibc 的版本过低导致的，那么问题来了 gnulib glib 和 glibc 分别指的什么呢 ？</p>
<blockquote>
<p>答： glibc 是一个 C 语言 运行时库, 例如 printf(3) fopen(3)</p>
</blockquote>
<blockquote>
<p>答： glib 是一个基于 C 语言的工具库，同时也是一个面向对象的事件循环</p>
</blockquote>
<blockquote>
<p>答： gnulib 是一个适配 POSIX API 和 native API 的库。</p>
</blockquote>
<p>那么问题又来了，到底什么是 runtime library 呢？</p>
<blockquote>
<p>答: 运行时库就是程序运行的时候所需要依赖的库。运行时库就是程序运行的时候所需要依赖的库。<br>运行的时候指的是指令加载到内存并由CPU执行的时候。<br>C代码编译成可执行文件的时候，指令没有被CPU执行，这个时候算是编译时，就是编译的时候。</p>
</blockquote>
<p>参考：</p>
<ul>
<li><a href="https://stackoverflow.com/questions/2240120/glibc-glib-and-gnulib" target="_blank" rel="noopener">glibc, glib and gnulib</a></li>
<li><a href="https://stackoverflow.com/questions/2766233/what-is-the-c-runtime-library" target="_blank" rel="noopener">c runtime libray 是什么</a></li>
<li><a href="https://en.wikipedia.org/wiki/Runtime_library" target="_blank" rel="noopener">什么是 runtime library</a></li>
<li><a href="https://www.zhihu.com/question/20607178" target="_blank" rel="noopener">运行时（runtime）是什么意思？应该怎样深入且直观地理解？</a></li>
</ul>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/o/2019/11/28/worker/" itemprop="url">JavaScript 中的线程与 Event Loop</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2019-11-28T03:56:39.000Z" itemprop="datePublished">11月 28 2019</time>
        </span>
        
        
        <span class="column is-narrow">
            
            
            14 分钟 读完 (约 2159 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="为什么-JavaScript-是单线程"><a href="#为什么-JavaScript-是单线程" class="headerlink" title="为什么 JavaScript 是单线程"></a>为什么 JavaScript 是单线程</h2><p>众所周知 JavaScript 最开始是被设计运行在浏览器中的脚本语言，从浏览器的功能和特性角度来讲，单线程是最合适的。多个线程操作 DOM 的时候容易出现此类问题：这个 DOM 应该被哪个线程控制的问题？ 因此为了避免问题的复杂性，从诞生开始 JavaScript 就是单线程，这已经成为这门语言的核心特征。</p>
<p>随着硬件资源（具体指的是 CPU 核数）不断提升和业务场景的不断的扩大（密集型计算、游戏），需要充分利用多核能力。 HTML 5 提出 Web Worker 标准， 允许 JavaScript 脚本创建多个线程，但主线程完全控制子线程且子线程没有操作 DOM 的权限, 所以说并没有改变 JavaScript 单线程的本质。</p>
<h2 id="执行栈与任务队列"><a href="#执行栈与任务队列" class="headerlink" title="执行栈与任务队列"></a>执行栈与任务队列</h2><p>单线程意味着排队，必须按照书写代码的顺序执行下去 A -&gt; B -&gt; C -&gt; D，然而一旦哪一步执行的时间非常长就不得不进行长时间的等待，那么这个时候任务就不得不等着前面的执行完。<br>如果是计算量过大 CPU 忙不过来了倒也好说， 然而这时候 CPU 是闲着的，因为许多任务是比较缓慢的，例如： IO、网络，比如等到有结果才能继续执行。</p>
<p>那么可以把任务分为两种：同步任务（synchronous）、异步任务（asynchronous）。同步任务是指：一个任务执行完后再进行下一个任务，异步任务是说：不进入主线程而进入“任务队列（task queue）“的任务，只有“任务队列“通知主线程某个异步任务可以执行了，该任务才可以执行。</p>
<p>具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）</p>
<p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</span><br><span class="line"></span><br><span class="line">（2）主线程之外，还存在一个&quot;任务队列&quot;（task queue）。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。</span><br><span class="line"></span><br><span class="line">（3）一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</span><br><span class="line"></span><br><span class="line">（4）主线程不断重复上面的第三步。</span><br></pre></td></tr></table></figure><br>下图就是主线程和任务队列的示意图。</p>
<p><img src="https://raw.githubusercontent.com/EPSON-LEE/image-hosting/master/20191128151057.png" alt></p>
<p>只要主线程空了，就会去读取”任务队列”，这就是JavaScript的运行机制。这个过程会不断重复。</p>
<h2 id="事件和回调函数"><a href="#事件和回调函数" class="headerlink" title="事件和回调函数"></a>事件和回调函数</h2><p>“任务队列”是事件的队列，IO 设备每完成一项任务，就在“任务队列”中添加一个事件，表示相关的异步任务可以进入“执行栈”了。主线程读取“任务队列”，就是读取里面有哪些事件。</p>
<p>“任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。</p>
<p>所谓”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。</p>
<p>“任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。但是，由于存在后文提到的”定时器”功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。</p>
<h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><p>主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。</p>
<p><img src="https://raw.githubusercontent.com/EPSON-LEE/image-hosting/master/20191128152551.png" alt></p>
<p>上图中，主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部API，它们在”任务队列”中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取”任务队列”，依次执行那些事件所对应的回调函数。</p>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>除了放置异步任务的事件，”任务队列”还可以放置定时事件，即指定某些代码在多少时间之后执行。这叫做”定时器”（timer）功能，也就是定时执行的代码。</p>
<p>总之，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在”任务队列”的尾部添加一个事件，因此要等到同步任务和”任务队列”现有的事件都处理完，才会得到执行。</p>
<p>HTML5标准规定了setTimeout()的第二个参数的最小值（最短间隔），不得低于4毫秒，如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为10毫秒。另外，对于那些DOM的变动（尤其是涉及页面重新渲染的部分），通常不会立即执行，而是每16毫秒执行一次。这时使用requestAnimationFrame()的效果要好于setTimeout()。</p>
<p>需要注意的是，setTimeout()只是将事件插入了”任务队列”，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。</p>
<h3 id="定时器运行机制"><a href="#定时器运行机制" class="headerlink" title="定时器运行机制"></a>定时器运行机制</h3><p>setTimeout和setInterval的运行机制，是将指定的代码移出本轮事件循环，等到下一轮事件循环，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就继续等待。</p>
<p>这意味着，setTimeout和setInterval指定的回调函数，必须等到本轮事件循环的所有同步任务都执行完，才会开始执行。由于前面的任务到底需要多少时间执行完，是不确定的，所以没有办法保证，setTimeout和setInterval指定的任务，一定会按照预定时间执行。</p>
<h3 id="特殊的定时器语句"><a href="#特殊的定时器语句" class="headerlink" title="特殊的定时器语句"></a>特殊的定时器语句</h3><p>我们经常会看到这么一些语句 setTimeout(fn, 0)，那么他的意思真的是等待 0 秒后立即执行么？ 当然不会，正如上文所说需要等到上文全部执行完, 总之，setTimeout(f, 0)这种写法的目的是，尽可能早地执行f，但是并不能保证立刻就执行f。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h2 id="Node-js-中的-Event-Loop"><a href="#Node-js-中的-Event-Loop" class="headerlink" title="Node.js 中的 Event Loop"></a>Node.js 中的 Event Loop</h2><p><img src="https://raw.githubusercontent.com/EPSON-LEE/image-hosting/master/20191128155205.png" alt></p>
<p>根据上图， Node.js 的运行机制</p>
<p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">（1）V8引擎解析JavaScript脚本。</span><br><span class="line"></span><br><span class="line">（2）解析后的代码，调用Node API。</span><br><span class="line"></span><br><span class="line">（3）libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。</span><br><span class="line"></span><br><span class="line">（4）V8引擎再将结果返回给用户。</span><br></pre></td></tr></table></figure></p>
<h2 id="问题遗留"><a href="#问题遗留" class="headerlink" title="问题遗留"></a>问题遗留</h2><p>process.nextTick process.setImmediate setTimeout 的区别</p>
<p>引用：</p>
<ul>
<li><a href="https://www.zhihu.com/question/55364497" target="_blank" rel="noopener">Vue 中如何使用 MutationObserver 做批量处理？</a></li>
</ul>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/o/2019/11/28/browser/" itemprop="url">浏览器概览</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2019-11-28T02:20:36.000Z" itemprop="datePublished">11月 28 2019</time>
        </span>
        
        
        <span class="column is-narrow">
            
            
            18 分钟 读完 (约 2748 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <p><img src="https://raw.githubusercontent.com/EPSON-LEE/image-hosting/master/20191128115319.png" alt></p>
<h2 id="浏览器的组成结构"><a href="#浏览器的组成结构" class="headerlink" title="浏览器的组成结构"></a>浏览器的组成结构</h2><ol>
<li>用户界面</li>
</ol>
<p>包括地址栏、前进、后退、书签栏。</p>
<ol start="2">
<li>浏览器引擎</li>
</ol>
<p>在用户界面和浏览器引擎之间传送指令。</p>
<ol start="3">
<li>呈现引擎</li>
</ol>
<p>负责呈现浏览器内容，负责解析 HTML 和 CSS 内容，并将解析后的内容现实在屏幕上。</p>
<ol start="4">
<li>网络</li>
</ol>
<p>用于网络调用。</p>
<ol start="5">
<li>用户界面后台</li>
</ol>
<p>用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。</p>
<ol start="6">
<li>JavaScript 解释器</li>
</ol>
<p>解析执行 JavaScript 代码。</p>
<ol start="7">
<li>数据存储</li>
</ol>
<p>持久层，浏览器需要在硬盘上保存各种数据，例如 Cookie，新的 HTML 5 规范定义了网络数据库，这是一个完整轻便的网络数据库</p>
<p><img src="https://raw.githubusercontent.com/EPSON-LEE/image-hosting/master/20191128103147.png" alt></p>
<p>和大多浏览器不同，Chrome 的每个标签页分别对应一个呈现引擎实例，每个标签页都是一个独立的进程。</p>
<h2 id="呈现引擎"><a href="#呈现引擎" class="headerlink" title="呈现引擎"></a>呈现引擎</h2><p>呈现引擎，又称为渲染引擎也成为浏览器内核，在这方面又称为 UI 线程，这是由各大浏览器厂商根据 W3C 标准自行研发的， 常见的内核有四种 （Webkit (chrome, safari) Gecko(firefox)）。</p>
<h3 id="呈现主流程"><a href="#呈现主流程" class="headerlink" title="呈现主流程"></a>呈现主流程</h3><p>呈现引擎最大的作用是用于呈现，也就是在浏览器中显示请求的内容。一开始从网络层获取文档内容，内容大小限制一般在 8000 个块以内, 然后进行以下流程：</p>
<p><img src="https://raw.githubusercontent.com/EPSON-LEE/image-hosting/master/20191128104926.png" alt></p>
<p>使用 HTML 构建 DOM 结构，并将各个标记转换为 “内容树” 上的 DOM 节点。同时也会解析外部 CSS 文件以及样式文件中的样式数据。 HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构： 呈现树。</p>
<p>呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。</p>
<p>呈现树构建完毕之后，进入“布局”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是绘制 - 呈现引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。</p>
<p>示例：webkit 主流程示例图</p>
<p><img src="https://raw.githubusercontent.com/EPSON-LEE/image-hosting/master/20191128105617.png" alt></p>
<p>示例：Mozila 的 Gecko 呈现主流程引擎</p>
<p><img src="https://raw.githubusercontent.com/EPSON-LEE/image-hosting/master/20191128110700.png" alt></p>
<h2 id="JavaScript-解释器"><a href="#JavaScript-解释器" class="headerlink" title="JavaScript 解释器"></a>JavaScript 解释器</h2><p>什么是 JavaScript 解释器？简单地说，JavaScript 解释器就是能够“读懂” JavaScript 代码，并准确地给出代码运行结果的一段程序。</p>
<p>所以 JavaScript 解释器，又称为 JavaScript 解析引擎，又称为 JavaScript 引擎，也可以成为 JavaScript 内核，在线程方面又称为 JavaScript 引擎线程。比较有名的有 Chrome 的 V8 引擎（用 C/C++ 编写），除此外还有 IE9 的 Chakra、Firefox 的 TraceMonkey。它是基于事件驱动单线程执行的，JavaScript 引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个 JavaScript 线程在运行 JavaScript 程序。</p>
<p>学过编译原理的人都知道，对于静态语言来说（如Java、C++、C），处理上述这些事情的叫编译器（Compiler），相应地对于 JavaScript 这样的动态语言则叫解释器（Interpreter）。这两者的区别用一句话来概括就是：编译器是将源代码编译为另外一种代码（比如机器码，或者字节码），而解释器是直接解析并将代码运行结果输出。 比方说，firebug 的 console 就是一个 JavaScript 解释器。但我们无需过多在这些点上纠结。因为比如像 V8，它其实是为了提高 JavaScript 的运行性能，会在运行之前将 JavaScript 编译为本地的机器码然后再去执行，这样速度就快很多，相信大家对 JIT（Just In Time Compilation）一定不陌生吧。</p>
<p>JavaScript 解释器和我们平时讨论的 ECMAScript 有很大关系，标准的 JavaScript 解释器会根据 ECMAScript 标准去实现文档中对语言规定的方方面面，但由于这不是一个强制措施，所以也有不按照标准来实现的解释器，比如 IE6，这也是一直困扰前端开发的一个来由——兼容问题。有关 JavaScript 解释器的部分不做过于深入的介绍，但是由于我们对它有了部分的了解，接下来可以介绍一个新的部分——线程。</p>
<h3 id="JavaScript-与浏览器的线程机制"><a href="#JavaScript-与浏览器的线程机制" class="headerlink" title="JavaScript 与浏览器的线程机制"></a>JavaScript 与浏览器的线程机制</h3><p>作为浏览器脚本语言，JavaScript 主要用于处理页面中用户交互，以及操作 DOM 树、CSS 样式树（当然也包括服务器逻辑的交互处理）。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？当然我们可以通过锁来解决上面的问题。但为了避免因为引入了锁而带来更大的复杂性，从一诞生，JavaScript 就是单线程，这已经成了这门语言的核心特征。</p>
<p>我们可以回顾一下最开始所提的一个问题：Web Worker 真的让 JavaScript 拥有了多线程的能力吗？</p>
<p>为了利用多核 CPU 的计算能力，在 HTML5 中引入的工作线程使得浏览器端的 JavaScript 引擎可以并发地执行 JavaScript 代码，从而实现了对浏览器端多线程编程的良好支持。Web Worker 允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM 。所以，这个新标准并没有改变 JavaScript 单线程的本质。</p>
<h3 id="为什么页面会卡顿？"><a href="#为什么页面会卡顿？" class="headerlink" title="为什么页面会卡顿？"></a>为什么页面会卡顿？</h3><p>由于 JavaScript 是可操纵 DOM 的，如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。为了防止渲染出现不可预期的结果，浏览器设置 UI 渲染线程与 JavaScript 引擎线程为互斥的关系，当 JavaScript 引擎线程执行时 UI 渲染线程会被挂起，UI 更新会被保存在一个队列中等到 JavaScript 引擎线程空闲时立即被执行。</p>
<p>于是，我们便明白了：假设一个 JavaScript 代码执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染出现“加载阻塞”的现象。当然，针对 DOM 的大量操作也会造成页面出现卡顿现象，毕竟我们经常说：DOM 天生就很慢。</p>
<p>所以，当你需要考虑性能优化时就可以从如上的原因出发，大致有以下几个努力的方面：</p>
<ul>
<li>减少 JavaScript 加载对 DOM 渲染的影响（将 JavaScript 代码的加载逻辑放在 HTML 文件的尾部，减少对渲染引擎呈现工作的影响）；</li>
<li>避免重排，减少重绘（避免白屏，或者交互过程中的卡顿）；</li>
<li>减少 DOM 的层级（可以减少渲染引擎工作过程中的计算量）；</li>
<li>使用 requestAnimationFrame 来实现视觉变化（一般来说我们会使用 setTimeout 或 setInterval 来执行动画之类的视觉变化，但这种做法的问题是，回调将在帧中的某个时点运行，可能刚好在末尾，而这可能经常会使我们丢失帧，导致卡顿）；</li>
</ul>
<p>优化方面可以看 <a href="https://developers.google.com/web/fundamentals/performance/rendering/optimize-javascript-execution" target="_blank" rel="noopener">优化 JavaScript 的执行</a></p>
<h3 id="浏览器中的那些线程"><a href="#浏览器中的那些线程" class="headerlink" title="浏览器中的那些线程"></a>浏览器中的那些线程</h3><p>事实上我们在使用浏览器的时候都会涉及到网络工具、浏览器事件、定时器触发线程。事实上这些线程如果出现在主线程上的话工作效率会非常的低下（这里的工作效率指的是人能看到的渲染引擎渲染出的页面）所以浏览器为这些功能独立设计了其他的线程</p>
<ul>
<li><p>浏览器事件触发线程：当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待 JavaScript 引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX 异步请求等，但由于 JavaScript 的单线程关系所有这些事件都得排队等待 JavaScript 引擎处理</p>
</li>
<li><p>定时器触发线程：浏览器定时计数器并不是由 JavaScript 引擎计数的, 因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案</p>
</li>
<li><p>异步 HTTP 请求线程：在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript 引擎的处理队列中等待处理；</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇大部分基本摘抄 <a href="https://zhuanlan.zhihu.com/p/32751855" target="_blank" rel="noopener">聊聊 JavaScript 与浏览器的那些事 - 引擎与线程</a>和 <a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/" target="_blank" rel="noopener">浏览器的工作原理：新式网络浏览器幕后揭秘</a>主要是自己对浏览器结构的一个简单梳理、也是为下一篇 Event Loop 的铺垫。</p>
<p>引用：</p>
<ul>
<li><p><a href="https://zhuanlan.zhihu.com/p/32751855" target="_blank" rel="noopener">聊聊 JavaScript 与浏览器的那些事 - 引擎与线程</a></p>
</li>
<li><p><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈Event Loop</a></p>
</li>
<li><p><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/" target="_blank" rel="noopener">浏览器的工作原理：新式网络浏览器幕后揭秘</a></p>
</li>
</ul>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/o/2019/11/27/fe-leader/" itemprop="url">假如我来负责一家公司的前端体系</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2019-11-27T10:07:17.000Z" itemprop="datePublished">11月 27 2019</time>
        </span>
        
        
        <span class="column is-narrow">
            
            
            3 分钟 读完 (约 429 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <p><img src="https://raw.githubusercontent.com/EPSON-LEE/image-hosting/master/20200116195001.png" alt></p>
<p><img src="https://raw.githubusercontent.com/EPSON-LEE/image-hosting/master/20191127184203.png" alt="how to build a building a building"></p>
<p>很长一段时间都在和 SRE、Infra 合作主要做的是一些比较基础的服务。 这篇文章主要记录工作中做过的和自己见过的重要的东西，想象如果自己有一天到了一家没有技术的公司自己都得做什么。</p>
<h2 id="私服"><a href="#私服" class="headerlink" title="私服"></a>私服</h2><p>在一个公司的前端开发中，理想情况是不同项目应当都使用公司提供的脚手架，并且由 infra 做统一维护。<br>但是做过开发的人都知道，做开发时不会每个组件都自己写，我们通常会引用一些外部文件（JavaScript -&gt; node_modules, Java -&gt; Maven）。<br>这个时候我们希望能把公司开发者使用的组件、包都放在自己的服务器上，因为主要有以下几点好处：</p>
<ol>
<li><p>节省自己的外网带宽</p>
</li>
<li><p>加速Maven、npm的构建，提升构建速度。</p>
</li>
<li><p>部署自己的第三方组件（公司的公共 node、 开发框架）</p>
</li>
</ol>
<p>node_modules 依赖</p>
<p>使用工具：</p>
<p><a href="https://help.sonatype.com/repomanager3" target="_blank" rel="noopener">Nexus Repository Manager OSS 3.x</a></p>
<h2 id="构建平台"><a href="#构建平台" class="headerlink" title="构建平台"></a>构建平台</h2><p>计划：主要包含 CI CD, 关于 jenkins 进行自动化共建的内容</p>
<h2 id="通用脚手架"><a href="#通用脚手架" class="headerlink" title="通用脚手架"></a>通用脚手架</h2><p>计划：</p>
<ul>
<li>web pc</li>
<li>H5</li>
<li>小程序</li>
<li>快应用</li>
<li>chrome extension</li>
</ul>
<h2 id="通用-CLI-工具"><a href="#通用-CLI-工具" class="headerlink" title="通用 CLI 工具"></a>通用 CLI 工具</h2><ul>
<li>作为通用脚手架的承载</li>
</ul>
<h2 id="文档体系"><a href="#文档体系" class="headerlink" title="文档体系"></a>文档体系</h2><p>主要用于知识分享</p>
<ul>
<li>docsify</li>
<li>vuepress</li>
</ul>
<h2 id="日志收集"><a href="#日志收集" class="headerlink" title="日志收集"></a>日志收集</h2><p>对线上页面进行日志收集以便快速定位问题</p>
<h2 id="性能监控"><a href="#性能监控" class="headerlink" title="性能监控"></a>性能监控</h2><p>对线上问题进行性能监控</p>

    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/o/2019/11/21/source/" itemprop="url">源码阅读计划</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2019-11-21T09:29:50.000Z" itemprop="datePublished">11月 21 2019</time>
        </span>
        
        
        <span class="column is-narrow">
            
            
            12 分钟 读完 (约 1811 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <p><img src="https://raw.githubusercontent.com/EPSON-LEE/image-hosting/master/20191122111156.png" alt></p>
<p>一直以来受到技术论坛的“荼毒”，要阅读源码。我也就按照很多论坛中说的那样，git clone 一份代码就开始看，结局都不怎么好。主要还是因为以下几种原因：</p>
<blockquote>
<p>技术方面说：</p>
</blockquote>
<ol>
<li>语法特性掌握还不够</li>
</ol>
<p>比如说看到 Reflect.defineProperty、Proxy 等一些日常业务开发中少见的用法时不能很好的理解其中的细节，频繁的中断会降低个人学习体验。</p>
<ol start="2">
<li>对 JavaScript 这门语言的设计哲学认识还不够</li>
</ol>
<p>原型链几乎每个前端都知道，要真的问也都能插上几句话。这个东西长时间不看确实会忘， 正如 <a href="https://www.cnblogs.com/wangfupeng1988/p/3977924.html" target="_blank" rel="noopener">王福朋这篇经典的文章中提到</a> 的他每次面试前都要看看。但个人认为原型链是 web 前端开发中不多的值得深刻记忆的东西。</p>
<ol start="3">
<li>构建工具相关的体系</li>
</ol>
<p>前端开发在最近几年发展迅速，工程化工具也伴随着剧烈变化通常都是 break changes，比如说第一份工作使用 webpack 2.0 进行打包 React，现在我的电脑里还留着一坨关于 webpack 2.0 配置的宝贝。但是第二份工作却是使用 vue 进行开发，有了 vue.config.js 这么好使的玩意儿对 webpack 4.0 生疏也是难免, 毕竟在业务开发中很够用。</p>
<p>再比如说 babel6.0 和 babel 7.0 的区别，按照官网来配置有时候也跑不通。</p>
<p>源代码中有许多工程性质的配置和针对运行时的特殊优化，对构建工具不清不楚看起来自然会很懵逼。</p>
<ol start="4">
<li>数据结构与算法的缺失</li>
</ol>
<p>比如 vue keep-alive 的实现方式，如果你不了解 LRU 的话，我想很难去看明白他在做什么。</p>
<blockquote>
<p>学习方法和心理来说：</p>
</blockquote>
<p>过去相当长的一段时间总有这么一种观点：沉浸在技术论坛有助于我的极速成长，我的技术视野得到了扩展但是针对现阶段的我造成的弊端也足够明显。</p>
<ol>
<li>持续性</li>
</ol>
<p>看到新的技术或名词总想去试试，但浅尝辄止的尝试并不能给现阶段的自己带来过多的帮助甚至会带来迷茫，如果真的想把现在所做的事当作一辈子的事业来做的话这种做法显然有些浮躁了。</p>
<ol start="2">
<li>自信心</li>
</ol>
<p>看到各种名词、术语、理念、思想自己都不明白经常会给我带来一种深厚的挫败感。从自己走过来的两年再回头看：这些人出于扩展自己的技术影响力也好、分享也好、还是宣传自己也好，很多都是人为的造词或者新瓶装旧酒。</p>
<p>说到这，想起最近发生的一件事： 某司的人力资源领导被优化了，他曾在去年的年底在自媒上发过一篇文章 《行业寒冬之下，为什么被裁的总是你》。</p>
<p>总之作为一个互联网从业者应当具备很强的信息甄别能力。</p>
<ol start="3">
<li>roadMap</li>
</ol>
<p>当你迷茫的时候不知道学什么的时候，第一种方法是去看计算机相关书籍，数据结构与算法也好操作系统也好计算机网络也好。</p>
<p>如果你觉得这种方式太枯燥太理论派你更直接一点的话，可以去找相关机构、课程的目录，但是我觉得没有必要去为此付费，按图索骥的按照目录去学习就好。</p>
<h1 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h1><p>首先从比较小的代码区块看起，比如:</p>
<p><a href="https://www.30secondsofcode.org/" target="_blank" rel="noopener">30 seconds of code</a></p>
<p><a href="https://github.com/ramda/ramda" target="_blank" rel="noopener">ramdaJS</a></p>
<p>之前看ramada的时候遇到一个问题，在 stackoverflow 上提问还收到了作者的回答，</p>
<h1 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h1><p>第二步：找到了看源码的感觉后，再去看某个类库的源码，比如说redux、moment这种，功能专一同时也兼顾深度。</p>
<p><a href="https://github.com/brickspert/blog/issues/22" target="_blank" rel="noopener">完全理解 redux</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/80655889" target="_blank" rel="noopener">带着问题看React-Redux源码（一万四千字长文预警</a></p>
<h1 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h1><p>这时候自己有了一定的基础和感觉了，可以再去看现在mvvm框架实现的原理，也是从单一的功能开始，拆解mvvm框架的通用实现模式，如双向绑定、虚拟dom等，最后实现自己的mini mvvm。</p>
<p><a href="https://juejin.im/post/5b1fa77451882513ea5cc2ca" target="_blank" rel="noopener">50行代码的MVVM，感受闭包的艺术</a></p>
<p><a href="https://juejin.im/post/5abdd6f6f265da23793c4458" target="_blank" rel="noopener">不好意思！耽误你的十分钟，让MVVM原理还给你</a></p>
<h1 id="第四阶段"><a href="#第四阶段" class="headerlink" title="第四阶段"></a>第四阶段</h1><p>这时候你具备了看react、vue这种框架的能力了，最好还是带着问题去看，比如看react fiber的原理、如何渲染的，setState怎么操作等等。</p>
<p><a href="https://juejin.im/post/599b8f066fb9a0247637d61b" target="_blank" rel="noopener">[React技术内幕] setState的秘密</a></p>
<p><a href="https://juejin.im/post/5ad81c24f265da504c168c85" target="_blank" rel="noopener">怎样学习React？当然是自己动手实现一个React啦</a></p>
<p>但是实际开发中没有这种造轮子的机会，大家的关注点更多还是放在业务上</p>
<blockquote>
<p>多端秒开方案、性能优化相关</p>
</blockquote>
<p><a href="http://blog.cnbang.net/tech/3477/" target="_blank" rel="noopener">移动 H5 首屏秒开优化方案探讨</a></p>
<blockquote>
<p>工程化套件（脚手架、开发调试工具、发布管理）</p>
</blockquote>
<p><a href="https://juejin.im/post/5d650613f265da03951a0364" target="_blank" rel="noopener">15分钟搭一个企业级脚手架</a></p>
<p><a href="https://juejin.im/post/5b23f18b6fb9a00e6433536d" target="_blank" rel="noopener">前端自动化发布实战总结</a></p>
<blockquote>
<p>数据埋点/监控</p>
</blockquote>
<p><a href="https://juejin.im/post/5b62d68df265da0f9d1a1cd6" target="_blank" rel="noopener">前端埋点的设计方案</a></p>
<blockquote>
<p>多端融合</p>
</blockquote>
<p><a href="https://link.zhihu.com/?target=https%3A//aotu.io/notes/2018/06/07/Taro/">多端统一方案 Taro</a></p>
<p><a href="https://juejin.im/post/5b2869e66fb9a00e5f3e861f" target="_blank" rel="noopener">Awesome Flutter：带你从入门到进阶的 Flutter 指南</a></p>
<blockquote>
<p>组件库</p>
</blockquote>
<ol>
<li>pre code</li>
<li>low code </li>
</ol>
<blockquote>
<p>互动平台、直播</p>
</blockquote>
<p><a href="https://juejin.im/post/5ab851b6f265da23826df601" target="_blank" rel="noopener">直播原理与web直播实战</a></p>
<blockquote>
<p>SSR 微前端</p>
</blockquote>
<p><a href="https://juejin.im/post/5d7deef6e51d453bb13b66cd" target="_blank" rel="noopener">一文吃透 React SSR 服务端渲染和同构原理</a></p>
<blockquote>
<p>BFF、Serverless、BFF in Serverless</p>
</blockquote>
<p><a href="https://juejin.im/post/5cdc3dc2e51d453b6c1d9d3a" target="_blank" rel="noopener">BFF、Serverless、以及BFF in Serverless</a></p>
<blockquote>
<p>灰度平台/ABtest等等</p>
</blockquote>
<p><a href="https://juejin.im/post/5da88d795188252f051e2b47" target="_blank" rel="noopener">https://juejin.im/post/5da88d795188252f051e2b47</a></p>
<blockquote>
<p>软技能</p>
</blockquote>
<p><a href="https://juejin.im/post/5bf2382d6fb9a049d974ccb6" target="_blank" rel="noopener">软技能-代码之外的生存指南1(职业篇)</a></p>
<p><a href="https://juejin.im/post/5ad06fc851882555635ebc9c" target="_blank" rel="noopener">工程师如何在工作中提升自己?</a></p>
<p>参考：</p>
<p>路线图大部分参考了知乎中的这篇回答<a href="https://www.zhihu.com/question/350289336/answer/873350617?utm_source=wechat_session&utm_medium=social&utm_oi=43031923261440" target="_blank" rel="noopener">一年经验的前端开发工程师看不懂源码怎么办，</a></p>

    
    </div>
    
    
</article>




    
    
        
<nav class="pagination is-centered is-rounded" role="navigation" aria-label="pagination">
    <div class="pagination-previous">
        <a href="/o/page/3/">上一页</a>
    </div>
    <div class="pagination-next">
        <a href="/o/page/5/">下一页</a>
    </div>
    <ul class="pagination-list is-hidden-mobile">
        
        <li><a class="pagination-link" href="/o/">1</a></li>
        
        <li><a class="pagination-link" href="/o/page/2/">2</a></li>
        
        <li><a class="pagination-link" href="/o/page/3/">3</a></li>
        
        <li><a class="pagination-link is-current" href="/o/page/4/">4</a></li>
        
        <li><a class="pagination-link" href="/o/page/5/">5</a></li>
        
    </ul>
</nav>
    
    </div>
</section>
    <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2021 leejiahao&nbsp;
                我所做的一切，不过是在取悦一个影子 </a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            <div class="column is-narrow">
                <div class="columns is-mobile is-multiline is-centered">
                
                    
                <a class="column is-narrow has-text-black" title="GitHub" href="https://github.com/EPSON-LEE" target="_blank" rel="noopener">
                    
                    GitHub
                    
                </a>
                
                </div>
            </div>
            
            
        </div>
    </div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/" target="_blank" rel="noopener">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        // plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
    moment.locale("zh-CN");
</script>


    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        "HTML-CSS": {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
</script>

    
    
    
    
<script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script>
<script>
    (function ($) {
        $(document).ready(function () {
            if (typeof($.fn.lightGallery) === 'function') {
                $('.article.gallery').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof($.fn.justifiedGallery) === 'function') {
                $('.justified-gallery').justifiedGallery();
            }
        });
    })(jQuery);
</script>

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
    <style>
        .hljs {
            position: relative;
        }

        .hljs .clipboard-btn {
            float: right;
            color: #9a9a9a;
            background: none;
            border: none;
            cursor: pointer;
        }

        .hljs .clipboard-btn:hover {
          color: #8a8a8a;
        }

        .hljs > .clipboard-btn {
            display: none;
            position: absolute;
            right: 4px;
            top: 4px;
        }

        .hljs:hover > .clipboard-btn {
            display: inline;
        }

        .hljs > figcaption > .clipboard-btn {
            margin-right: 4px;
        }
    </style>
    <script>
      $(document).ready(function () {
        $('figure.hljs').each(function(i, figure) {
          var codeId = 'code-' + i;
          var code = figure.querySelector('.code');
          var copyButton = $('<button>Copy <i class="far fa-clipboard"></i></button>');
          code.id = codeId;
          copyButton.addClass('clipboard-btn');
          copyButton.attr('data-clipboard-target-id', codeId);

          var figcaption = figure.querySelector('figcaption');

          if (figcaption) {
            figcaption.append(copyButton[0]);
          } else {
            figure.prepend(copyButton[0]);
          }
        })

        var clipboard = new ClipboardJS('.clipboard-btn', {
          target: function(trigger) {
            return document.getElementById(trigger.getAttribute('data-clipboard-target-id'));
          }
        });
        clipboard.on('success', function(e) {
          e.clearSelection();
        })
      })
    </script>

    
    

    



<script src="/o/js/script.js"></script>


    
    <div class="searchbox ins-search">
    <div class="searchbox-mask"></div>
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="站内搜索" />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '页面',
                CATEGORIES: '分类',
                TAGS: '标签',
                UNTITLED: '(无标题)',
            },
            CONTENT_URL: '/o/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>

<script src="/o/js/insight.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

    
</body>
</html>